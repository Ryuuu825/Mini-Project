// stack 
var a : str = "a" // fixed size string
var b : int = 10 
arr c : int[10] = [1,2,3,4,5,6,7,8,9,10] // array
tup c : int[10] = (1,2,3,4,5,6,7,8,9,10) // tuple
var d : mut int = c[0]
ref e : mut int = &d // const reference of an int 
ref f : mut int = &c[0] // const reference of an int 
mref g : mut int = &d // mutable reference of a const int
move h : mut int = d // move d value to h , and d is not longer valid
move i : int = d // move d value to i , and d is not longer valid
move j : mut int = &d // invalide move. program halt 
golvar k : mut int = 10 // golbal variable
svar l : mut int = 10 // static / private file scope variable
let m : auto = 10 // auto type inference
let n : mut int = 10 // explicit type
var a , b : int = 10 // multiple assignment

// heap 
heap i : Object = & ( create Object {} ) // create an object on the heap
delete i // manual delete


heap j : InputStream = & ( create InputStream { file = stddef::stdin } ) // create an input stream on the heap
let input : mut String = InputStream.readline(j) // read from the stream
seeout input 
InputStream.close(j) // close the stream
delete j // manual delete

#Debug  
#end 

#Release
#end

if a is str { // check the type of a
    seeout a 
    seeout b , c
}
elif a == "10" {
    see b // print to default output stream 
}
else {
    seeerr "not a str"
}

struct Point [x:int = 0 , y :int = 1]
enum Color : Integer {
    Red = 1,
    Green = 2,
    Blue = 
}

var p : Point = create Point {x:1,y:2}
var p : Point? = create Point {x:1,y:2} // optional point
var p : Point? = null // is a point object or null object 

struct Person [
    name :str = "",
    age :int = 0,
]

struct Student : Person [
    id :int = 0,
    grade :int = 0,
]

extension Person [
    fn public saySth ( [self] , ref msg : str ) : void
    {
        seeout msg
    }

    fn private sayHello ( [self]) : void
    {
        Person.saySth(self , "hello")
    }
] 


fn add(var x : int , var y : int ) : int
{
    return x + y
}

fn get_var_from_array(ref arr : const int[10] , var index : int ) : int
{
    return arr[index]
}

fn add_one_to_each_element(mref arr : const int[10] ) : void
{
    for i in 0..10 {
        arr[i] += 1
    }
}

fn movevaluetothisfunction(move x : int ) : void
{
    seeout x
} // x is not valid anymore

var p : Person = {"name" , 18}
Person.saySth(p , "hello")


%marco run_time_macro (x) `seeout {x}`
%run_time_macro(10)

true
false 

true && false 
true || false
!true

var a : int = try! 10 // if try is success , return value , else throw exception
var a : int = try? 10 // if try is success , return value , else return null
var a : int = try! 10 catch ( e : Exception ) {
    seeerr Exception.error(e)
    return 0
}

#import <io.ff>
#import "test.ff"

seeout f"{a : i , l10}"

namespace test {
    struct Point [x:int = 0 , y :int = 1]
}

var p : test::Point = {1,1}

throw create Exception {
    error = "error"
}

typeof(p) 
nameof(p)
sizeof(p)
lenof(p)


let a : Person = {
    let a = create Person {name:"a",age:10}
    Person.say_hello(a)
    return a
}

while(true) {
    seeout "hello"
}

for i in 10..20 {
    seeout i
}

for i in lenof(p) {
    seeout i
}

foreach element in p {
    seeout element
}

for i in 10..20 |+10| {
    seeout i
}

for (i = 10 ; i < 20 ; i++) {
    seeout i
}