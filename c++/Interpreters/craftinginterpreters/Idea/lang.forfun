// stack 
var a : str = "a" // fixed size string
var b : int = 10 
arr c : int[10] = [1,2,3,4,5,6,7,8,9,10] // array
tup c : int[10] = (1,2,3,4,5,6,7,8,9,10) // tuple
var d : mut int = c[0]
ref e : mut int = &d // const reference of an int 
ref f : int = &c[0] // const reference of an int 
ref g : mut int = &d // mutable reference of a const int
golvar k : mut int = 10 // golbal variable
svar l : mut int = 10 // static / private file scope variable
var a , b : int = 10 // multiple assignment


#Debug  
#end 

#Release
#end

if a is str { // check the type of a
    seeout a 
    seeout b , c
}
elif a == "10" {
    see b // print to default output stream 
}
else {
    seeerr "not a str"
}

struct Point [x:int = 0 , y :int = 1]
enum Color : Integer {
    Red = 1,
    Green = 2,
    Blue = 
}

var p : Point = create Point {x:1,y:2}
var p : Point? = create Point {x:1,y:2} // optional point
var p : Point? = null // is a point object or null object 

struct Person [
    name :str = "",
    age :int = 0,
]

struct Student : Person [
    id :int = 0,
    grade :int = 0,
]

extension Person [
    fn pub saySth ( [self] , ref msg : str ) -> void
    {
        seeout msg
    }

    fn sayHello ( [self]) -> void
    {
        Person.saySth(self , "hello")
    }
] 


fn add(var x : int , var y : int ) -> int
{
    return x + y
}

fn get_var_from_array(ref arr : const int[10] , var index : int ) -> int
{
    return arr[index]
}

fn add_one_to_each_element(mref arr : const int[10] ) -> void
{
    for i in 0..10 {
        arr[i] += 1
    }
}

fn movevaluetothisfunction(move x : int ) -> void
{
    seeout x
} // x is not valid anymore

var p : Person = {"name" , 18}
Person.saySth(p , "hello")



true
false 

true && false 
true || false
!true

var a : int = try! 10 // if try is success , return value , else throw exception
var a : int = try? 10 // if try is success , return value , else return null
var a : int = try! 10 catch ( e : Exception ) {
    seeerr Exception.error(e)
    return 0
}



seeout f"{a : i , l10}"

namespace test {
    struct Point [x:int = 0 , y :int = 1]
}

var p : test::Point = {1,1}

throw create Exception {
    error = "error"
}

typeof(p) 
nameof(p)
sizeof(p)
lenof(p)


let a : Person = {
    let a = create Person {name:"a",age:10}
    Person.say_hello(a)
    return a
}

while(true) {
    seeout "hello"
}

for i in 10..20 {
    seeout i
}

for i in lenof(p) {
    seeout i
}

foreach element in p {
    seeout element
}

for i in 10..20 |+10| {
    seeout i
}

for (i = 10 ; i < 20 ; i++) {
    seeout i
}

#test["test"] expected IOException 
fn test(var a : int) : void
{
    seeout a
}

#test["test"] expected -> double 
fn test(var a : int) : double
{
    return a
}


#import <io.ff>
#import "test.ff"

import ["Collection.Vector"] from <Collection>
import "test.ff"
